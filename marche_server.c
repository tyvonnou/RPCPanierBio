/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "marche.h"
#include <string.h>
#define MAX_COMPTE 100
gestionCompte magestionCompte;
int indexcompte = 1;
int indexarticle = 0, compteactif = 0;
int indexcommande = 0;

// Gestion de l'inscription
compte *
inscription_1_svc(compte *compte, struct svc_req *rqstp)
{
	int i;
	static char * result;
	if(magestionCompte.mescomptes[0].email == '\0'){
			printf("init\n");
	}
	// Si le type est valide
	if (compte->type >= 0 && compte->type <= 3) {
		// Si le nom n'est pas NULL je continue
		if(compte->nom[0] != '\0'){
			// Si pas de prÃ©nom pour un client
			if(compte->prenom[0] == '\0' && compte->type == 1){
				//Affichage de l'erreur
				printf("Erreur : Le prenom est NULL pour le compte client\n");
				return (void *) &result;
			}
			// Si l'email est valable je continue
			if (compte->email[0] != '\0') {
				for(i=0;i<3;i++){
					if((strcmp(magestionCompte.mescomptes[i].email, compte->email) == 0)){
						compte->type = -8;
						compte->password[0] = '\0';
						printf("ERREUR: Doublons email inscription\n");
					}
				}
				if (compte->password[0] != '\0') {
					if (compte->adresse[0] != '\0') {
						// Allocations
						// magestionCompte.mescomptes[indexcompte].adresse = (char *) malloc(sizeof(char)*20);
						// magestionCompte.mescomptes[indexcompte].nom = (char *) malloc(sizeof(char)*20);
						// magestionCompte.mescomptes[indexcompte].prenom = (char *) malloc(sizeof(char)*20);
						// magestionCompte.mescomptes[indexcompte].password = (char *) malloc(sizeof(char)*20);
						// magestionCompte.mescomptes[indexcompte].email = (char *) malloc(sizeof(char)*20);
						// Attribution
						strcpy(magestionCompte.mescomptes[indexcompte].adresse, compte->adresse);
						strcpy(magestionCompte.mescomptes[indexcompte].email, compte->email);
						magestionCompte.mescomptes[indexcompte].type = compte->type;
						strcpy(magestionCompte.mescomptes[indexcompte].nom, compte->nom);
						strcpy(magestionCompte.mescomptes[indexcompte].prenom, compte->prenom);
						strcpy(magestionCompte.mescomptes[indexcompte].password, compte->password);
						printf("Informations nouvelle inscription : \n id : %d\n email: %s\n",
						indexcompte,
						compte->email);
						indexcompte++;
					} else {
						printf("Erreur : L'adresse' est NULL\n");
					}
				} else {
					printf("Erreur : Le mot de passe est NULL\n");
				}
			} else {
				// Erreur si l'email est NULL
				printf("Erreur : L'email est NULL\n");
			}
		} else {
			// Erreur si le nom est NULL
			printf("Erreur : Le nom est NULL\n");
		}
	} else {
		// Erreur si mauvais type
		printf("Erreur : Le type n'est pas valide, 1 = client, 2 = fournisseur, 3 = point relais\n");
	}
		return compte;
	}


// Gestion de la connexion
compte *
connexion_1_svc(compteConnexion *compteConnexion, struct svc_req *rqstp)
{
	static compte  result;
	int i;

	for(i = 1; i<indexcompte; i++){
		printf("Informations nouvelle connexion : \n %d -> %s == %s && %s == %s ?\n",i,magestionCompte.mescomptes[i].email, compteConnexion->email, 	magestionCompte.mescomptes[i].password,compteConnexion->password);
		if((strcmp(magestionCompte.mescomptes[i].email, compteConnexion->email) == 0) &&
			(strcmp(magestionCompte.mescomptes[i].password, compteConnexion->password) == 0)){
				printf("oui\n");
				strcpy(result.adresse, magestionCompte.mescomptes[i].adresse);
				strcpy(result.nom, magestionCompte.mescomptes[i].nom);
				strcpy(result.prenom, magestionCompte.mescomptes[i].prenom);
				strcpy(result.email, magestionCompte.mescomptes[i].email);
				result.type = magestionCompte.mescomptes[i].type;
				strcpy(result.password, magestionCompte.mescomptes[i].password);
				compteactif = i;
				i = indexcompte;
		} else {
				printf("non\n");
				result.type = 4;
			}
	}
	return (compte *)&result;
}

// Ajout d'un produit
caddie *
ajoutcaddie_1_svc(gestionArticle *gestionArticle, struct svc_req *rqstp)
{

	strcpy(gestionArticle->moncaddie.mesArticles[indexarticle].nom, gestionArticle->unArticle.nom);
	strcpy(gestionArticle->moncaddie.mesArticles[indexarticle].description, gestionArticle->unArticle.description);
	gestionArticle->moncaddie.mesArticles[indexarticle].prix = gestionArticle->unArticle.prix;
	printf("%d -> Nouvel ajout\n",compteactif);
	return (caddie *) &gestionArticle->moncaddie;
}

// suppresion d'un produit
caddie *
supprimecaddie_1_svc(gestionArticle *gestionArticle, struct svc_req *rqstp)
{
	int i,j;
	for(i=0;i<3;i++){
		j =0;
		if(strcmp(gestionArticle->moncaddie.mesArticles[i].nom, "asup") == 0){
			strcpy(gestionArticle->moncaddie.mesArticles[i].nom, "");
			strcpy(gestionArticle->moncaddie.mesArticles[i].description, "");
			gestionArticle->moncaddie.mesArticles[i].prix = 0;
			printf("%d -> Nouvel suppresion\n",compteactif);
			// for(j = i;j<3;j++){
			// 	strcpy(gestionArticle->moncaddie.mesArticles[i].nom,gestionArticle->moncaddie.mesArticles[i+1].nom);
			// 	strcpy(gestionArticle->moncaddie.mesArticles[i].description,gestionArticle->moncaddie.mesArticles[i+1].description);
			// 	gestionArticle->moncaddie.mesArticles[i].prix = gestionArticle->moncaddie.mesArticles[i+1].prix;
			// 	strcpy(gestionArticle->moncaddie.mesArticles[i+1].nom,"");
			// 	strcpy(gestionArticle->moncaddie.mesArticles[i+1].description,"");
			// 	gestionArticle->moncaddie.mesArticles[i+1].prix = 0;
			// }
			}
		}
	return (caddie *) &gestionArticle->moncaddie;
}

// Signalement du payement
int *
payement_1_svc(payement *payement, struct svc_req *rqstp)
{
	static int   result =0;
	printf("%d", result);
	printf("%d -> Nouveau payement\n",compteactif);
	return (int *) &result;
}

// Signalement de la commande
commandes *
commandepayer_1_svc(gestionCommande *gestionCommande, struct svc_req *rqstp)
{		if(indexcommande == 2) indexcommande = 0;
		gestionCommande->listelivraison[indexcommande] = gestionCommande->livraison;
		printf("%d -> Nouvelle commande [%d]\n",compteactif, indexcommande);
		indexcommande ++;

	return (commandes *) &gestionCommande->listelivraison;
}
